# 7.20

[TOC]

## 指针和数组的区别

数组名不能当左值，当右值使用时，自动转换为首地址

实参数组和形参输出占用统一段空间

```c
char str[10]= "hello";
//这是一个字符串变量，是可以修改的
char *str="hello";
//这是一个指针，指向字符串常量的首地址，是不可更改的
```

```c
char a[2]= {'a','b'};
printf("%d\n",strlen(a));
```

虽然结果可能正确，但是是内存泄漏，strlen使用时要保证是字符串

但字符数组中存的不一定是字符串，而且strlen是以'\0'为结束标准的。

但如果写成：

```c
char a[3]={'a','b'};
```

就可实现，因为没有内容自动为0, 0相当于'\0'.

void *指针: 通用指针类型 和任意其他类型指针可以隐式转化

------

◼ NULL在C标准库的头文件stddef.h中定义：

```c
#define NULL ((void *)0)
```

◼就是把地址0转换成指针类型，称为空指针，它的特殊之处在于，操作系统不会把任何数据保存在地址0及其附近，也不会把地址0~0xfff的页面映射到物理内存，所以任何对地址0的访问都会立刻导致段错误。

```c
int a = 0x12345678;
char b =0x78;
char *p = &b;   //越界 4个字节存
printf("%x\d",*p);
```



## 进程内存分布

```tex
内核地址空间

环境变量

命令行参数

栈

共享库和mmap内存映射区

堆

数据段（data segment）

文本段（text segment）
```

## 编程基础四大件 
计算机网络、数据结构与算法、操作系统、设计模式

高强度刷题: LeetCode 牛客 把问题清晰准确的讲清楚

程序 my_strcmp.c

```c
int my_strcmp(char *s1,char *s2)
{
    while(*s1 != '\0')
    {
        if(*s1 != *s2)
        {
            break;
        }
        s1++;
        s2++;       
    }
    return *s1 -*s2;
  /*
   if(*s1 > *s2)
    {
        return 1;
    }else if(*s1 < *s2)
    {
        return -1;
    }else 
    {
        return 0;
    }
  
  
  */ 

}
```

 

