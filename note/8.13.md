# 8.13

## 守护线程
### 终端
- 在UNIX系统中，用户通过终端登录系统后 得到一个shell 进程，这个终端成为shell进程的控制终端，进程中，控制终端是保存在PCB中的信息，而fork（）会复制PCB中的信息，因此由shell进程启动的其他进程的控制终端也是这个这个终端
- 默认情况下（没有重定向），每个进程的标准输入，标注输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出在显示器上
- 在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 Ctrl+C 会产生SIGINT信号,Ctrl + \ 会产生SIGQUIT信号

### 进程组
- 进程组和会话在进程之间形成了一种两级层次关系吗，进程组是一组相关进程的集合，会话是一组相关进程组的集合。进程组合会话是为支持shell作业控制而定义的抽象概念，用户通过shell能够交互式地在前台或后台运行命令。
- 进程组有一个或多个共享概念股同一进程组标识符（PGID）的进程组成，一个进程组拥有一个进程组首地址，改进程是创建改组的进程，其进程ID为改组的组进程ID，新进程会继承其父进程所属的进程组ID。
- 进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外 一个进程组而退出进程组。进程做首进程无需是最后一个离开进程组的成员。
### 会话
- 会话是一组进程组的集合，会话首进程是创建改新会话的进程，其进程ID会成为该会话的ID，新进程会进程父进程的会话ID。
- 一个会话中的所有进程共享单个控制终端，控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能成为一个会话的控制终端。
- 在任一时刻，会话中的一个进程组会成为该终端的前台进程组，其他进程组会成为后台进程组，只有前台进程组中的进程才能从控制终端读取输入，当用户在控制终端输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员
- 当控制终端的连接建立起来后，会话首进程会成为该终端的控制进程
### 进程组 会话操作相关函数
```c
pid_t getpgrp(void);  //进程组ID获取
pid_t getpgid(pid_d pid);
int setpgid(pid_t pid,pid_t pgid);
pid_t getsid(pid_t pid); //会话ID获取
pid_t setsid(void);  //设置会话ID
```
### 守护线程
- 守护线程，也就是常说的Daemon进程（精灵进程），是linux中的后台服务进程。他是一个生存期较长的进程，通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。
- 守护进程具备下列特征：
- -  1.他的声明周期很长,守护进程会在系统启动的时候被创建并一直运行直到系统被关闭.
- -  2.他在后台运行并且不拥有控制终端,没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号(如SIGINT和SIGQUIT).
- linux的大多数服务器就是用守护进程实现的,比如internet服务器,inetd,web服务区httpd等。

### 守护进程的创建步骤
- 执行一个fork()，之后父进程退出，子进程继续执行。
- 子进程调用setsid()开启一个新对话。
- 清楚进程的umask以确保当守护进程创建文件和目录是拥有的所需的权限
- 修改进程的当前工作目录，通常设置为更目录、
- 关闭守护进程从其父进程继承而来的所有打开着的文件描述符
- 在关闭了文件描述符0,1,2之后，守护进程通常会打开/dev/null 并使用dup2()使所有这些描述符指向这个设备
- 核心业务逻辑


## 线程概述
- 与进程类似，线程是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同的程序，且共享同一份全局内存区域，其中包括初始化数据段，未初始化数据段，以及堆内存段。(传统意义上的unix进程只是多线程程序的一个特例，改进程只包含一个线程)
- 进程是cpu分配资源的最小单位，线程是操作系统调度执行的最小单位。
- 线程是轻量级的进程(LWP: Light Weight Process)，在linux环境下线程本质仍是进程.
- 查看指定进程的LWP号：ps -Lf (pid)

### 线程和进程的区别
- 进程间的信息难以共享，由于出去只读代码段外，父子进程并未共享内存，因此必须采用一个进程间通信方式，在进程间进行信息交换
- 调用fork()来创建进程的代价相对较高，即便使用写时复制技术，任然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着fork()调用在时间上的开销依然不菲。
- 线程之间能够方便。快速的共享信息。只需将数据复制到共享(内存或堆)变量中即可。
- 创建线程比创建进程通常要快10倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表。
- 