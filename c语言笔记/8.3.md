# 8.3

## union共用体，联合体

```c
#include<stdio.h>
union ss
{
	int a;
    char b[4];
};
int main()
{
	union ss s;
    s.a = 0x12345678;
    pritnf("%lu\n",sizeof(s));
    //输出的结果是4
}
```

## 程序：有名管道进行简单聊天

chatA程序：

```c
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<stdlib.h>
#include<fcntl.h>
#include<string.h>
int main(int argc, char const *argv[])
{
    //检查管道并创建管道
    int ret =access("fifo1",F_OK);
    if (ret == -1)
    {
        printf("fifo1 not exist,creating...\n");
        ret = mkfifo("fifo1",0664);
        if (ret == -1)
        {
            perror("makefifo");
            exit(0);
        }
    }
     ret =access("fifo2",F_OK);
    if (ret == -1)
    {
        printf("fifo2 not exist,creating...\n");
        ret = mkfifo("fifo2",0664);
        if (ret == -1)
        {
            perror("makefifo");
            exit(0);
        }
    }

    //先写
    int fdw = open("fifo1",O_WRONLY);
    if(fdw == -1)
    {
        perror("open");
        exit(0);
    }
    printf("打开 fifo1成功，等待写入数据\n");
    //后读
    int fdr = open("fifo2",O_RDONLY);
    if(fdr == -1)
    {
        perror("open");
        exit(0);
    }
    printf("打开 fifo2成功,等待读取\n");

    char buf[128];
    //循环输出
    while (1)
    {
        //fgets从键盘得到标注输入
        memset(buf,0,sizeof(buf));
        fgets(buf,sizeof(buf),stdin);
        //写管道数据
        int ret = write(fdw,buf,strlen(buf));
        if(ret == -1)
        {
            perror("write");
            exit(0);
        }
        //5.读管道数据
        memset(buf,0,sizeof(buf));
        ret = read(fdr,buf,sizeof(buf));
        if(ret <= 0)
        {
            perror("read");
            break;
        }
        printf("recv: %s\n",buf);
    }
    close(fdr);
    close(fdw);
    
    return 0;
}

```

chatB程序

```C
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<stdlib.h>
#include<fcntl.h>
#include<string.h>
int main(int argc, char const *argv[])
{
    //检查管道并创建管道
    int ret =access("fifo1",F_OK);
    if (ret == -1)
    {
        printf("fifo1 not exist,creating...\n");
        ret = mkfifo("fifo1",0664);
        if (ret == -1)
        {
            perror("makefifo");
            exit(0);
        }
    }
     ret =access("fifo2",F_OK);
    if (ret == -1)
    {
        printf("fifo2 not exist,creating...\n");
        ret = mkfifo("fifo2",0664);
        if (ret == -1)
        {
            perror("makefifo");
            exit(0);
        }
    }

    // 读文件描述符
    int fdr = open("fifo1",O_RDONLY);
    if(fdr == -1)
    {
        perror("open");
        exit(0);
    }
    printf("打开 fifo1成功，等待读取\n");
    //写文件描述符
    int fdw = open("fifo2",O_WRONLY);
    if(fdw == -1)
    {
        perror("open");
        exit(0);
    }
    printf("打开 fifo2成功,等待写入\n");

    char buf[128];
    //
    while (1)
    {
        //4.读管道数据
        memset(buf,0,sizeof(buf));
        ret = read(fdr,buf,sizeof(buf));
        if(ret <= 0)
        {
            perror("read");
            break;
        }
        printf("recv: %s\n",buf);

        //写管道数据
        memset(buf,0,sizeof(buf));
        fgets(buf,sizeof(buf),stdin);
        //
        int ret = write(fdw,buf,strlen(buf));
        if(ret == -1)
        {
            perror("write");
            exit(0);
        }
        
    }
    close(fdr);
    close(fdw);
    
    return 0;
}

```

## 使用内存映射在两个无关系的进程间通信

```c

```

## 内存映射的注意事项

1.如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?
void * ptr = mmap(...);
ptr++;  可以对其进行++操作
munmap(ptr,  );   // 错误,要保存地址

2.如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?
错误，返回MAP_FAILED
open()函数中的权限建议和prot参数的权限保持一致。

3.如果文件偏移量为1000会怎样?
偏移量必须是4K的整数倍，返回MAP_FAILED

4.mmap什么情况下会调用失败?
    - 第二个参数：length = 0
        - 第三个参数：prot
        - 只指定了写权限
        - prot PROT_READ | PROT_WRITE
          第5个参数fd 通过open函数时指定的 O_RDONLY / O_WRONLY

5.可以open的时候O_CREAT一个新文件来创建映射区吗?

    - 可以的，但是创建的文件的大小如果为0的话，肯定不行
        - 可以对新的文件进行扩展
        - lseek()
        - truncate()

6.mmap后关闭文件描述符，对mmap映射有没有影响？
    int fd = open("XXX");
    mmap(,,,,fd,0);
    close(fd); 
    映射区还存在，创建映射区的fd被关闭，没有任何影响。

7.对ptr越界操作会怎样？
void * ptr = mmap(NULL, 100,,,,,);
4K
越界操作操作的是非法的内存 -> 段错误