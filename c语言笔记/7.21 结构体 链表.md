# 7.21 结构体 链表

## 结构体初讲

结构体 32个字节 按值传递占用很大 速度慢

```c
#include <stdio.h>
typedef struct student 
{
int id;
char name[10];
int age;
char sex;
}student_t;   //重定名 加上typedef即可和不同变量一样 不用初始化时添加struct
void print_student(student_t s)
{
	 printf("%d %s %d %c\n",s.id,s.name,s.age,s.sex);

}
int main()
{
 student_t s1={1,"张三",19,'m'};
 student_t s2={3,"李四",19,'f'};
 print_student(s1);
  print_student(s2);


}
```

可以改成按地址传递

```c
void print_student(student_t *s)
{
	 printf("%d %s %d %c\n",s->id,s->name,s->age,s->sex);
		s->age = 16;
}
int main()
{
 student_t s1={1,"张三",19,'m'};
 student_t s2={3,"李四",19,'f'};
 print_student(&s1);   //结果 19
  print_student(&s1);   //结果 16


}
```
指针32位系统4个字节 64位系统8个字节
.表示对象本身 ->表示指针

**c语言中 结构体 不能包含自己本身**

## 链表

### 链表的定义
**数据域加指针域 next指向下一个区域** 
```c
#include <stdio.h>
typedef struct student 
{
int id;
char name[10];
int age;
char sex;
struct student *next;
}student_t;
```

###  遍历链表
```

void traverse()
{
	student_t *p =head;
	while(p != NULL)
	{
		print_student(p);
		p = p ->next;
	}
}
```
### 链表的基本操作(创建节点、插入节点、遍历链表、查找、删除节点 销毁链表)
```c
#include<stdio.h>
#include<stdlib.h>
typedef struct node
{
int data;
struct node *next;
}node;
node *head =NULL;
//1.创建节点
node *create_node(int data)
{
    node *p =(node*)malloc(sizeof(node));
    if(p == NULL)
    {
        printf("create node filed!");
        exit(1);
    }else
    {
        p ->data = data;
        p ->next = NULL; 
        return p;
    }
}
//2.释放节点
void free_node(node *p)
{
    free(p);
}
//3.插入节点（头插法）
node *insert_node(node* p)
{
    p ->next = head;
    head = p;
}
//删除节点
void del_node(node *p)
{
    node * pre;
    if(head == p)
    {
        head = head->next;
        p->next = NULL;
        free_node(p);
        return ;
    }
    pre = head;
    while(pre->next != NULL)
    {
        if(pre->next == p)
        {
            pre->next = p->next;
            p->next =NULL;
            free_node(p);
        } 
        pre = pre->next;
    }
       

}
//遍历数组
void traverse()
{   node *p=head;
    if(p == NULL)
    {
        printf("列表为空！");
    }
    while(p != NULL)
    {
        printf("%d ",p->data);
        p = p->next;
    }
    printf("\n");
}
//搜索节点
node *search_node(int target)
{
    node *p =head;
    while(p != NULL)
    {
        if(p->data == target)
        {
            return p;
        }
        p = p->next;
    }
    return NULL;
}
//销毁链表
void destory()
{
    node *p;
    while(head != NULL)
    {
        p =head;
        head = head->next;
        free_node(p);
    }
}
int main(int argc, char const *argv[])
{
    int target;
    for (int i = 0; i < 10; i++)
    {
        node *new_node=create_node(rand()%100+3);
        insert_node(new_node);
    }
    traverse();
    scanf("%d",&target);
    node *find = search_node(target);
    if(find == NULL)
    {
        printf("没找到！");
    }else
    {
        printf("%p %d %d",find,find->data,target);
    }
    printf("\n");
    del_node(find);
    traverse();
    printf("\n");
    destory();
    traverse();
    
    return 0;
}

```

## 动态内存分配



```c
#include <stdlib.h>
void *malloc(size_t size);
void free(void *pointer);
```



```c
#include <stdlib.h>
void *calloc( size_t num_elements, size_t elements_size);
calloc的特殊之处: 将数组的元素都初始化为零。
void *realloc(void *ptr, size_t new_size);
```

