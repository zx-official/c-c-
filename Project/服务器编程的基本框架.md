# 服务器编程的基本框架
| 模块         | 功能                       |
| ------------ | -------------------------- |
| io处理单元   | 处理客户连接，读写网络数据 |
| 逻辑单元     | 业务进程或者线程           |
| 网络存储单元 | 数据库，文件或缓存         |
| 请求队列     | 各单元之间的通信方式       |

- io处理单元是服务器管理客户连接的模块，他通常要完成以下工作：等待并接受新的客户连接，接受客户数据，将服务器的响应数据返回给客户端，但是数据的收发不一定子啊IO处理单元中执行，也可能在逻辑单元中惊醒，具体在何处执行取决于事件处理模式
- 一个逻辑单元通常是一个线程或者进程，他分析并处理客户数据，然后将结果传递给IO处理单元或者直接发送给客户端(取决于事件处理模式).服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理。
- 网络存储可以是数据库，缓存和文件，但不是必须的
- 请求队列是各单元之间通信方式的抽象，io处理单元收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求，同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件，请求队列通常被实现为池的一部分。

# 两种高效的事件处理模式
服务器程序通常处理的三类事件：IO事件，信号及定时事件。有两种高效的事件处理方式：reactor和proactor，同步io模型通常用于实现reactor模式，异步io模型通常用于实现proactor
## reactor模式
- 要求主线程(io处理单元)只负责监听文件描述符上是否有时间发生，有的话就立即将该事件通知工作线程(逻辑单元)，将socket可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作，读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。

- 使用同步IO模拟(以epoll_wait为例)实现的reactor模式的工作流程是：
1. 主线程往epoll内核事件表中注册socket上的读就绪事件
2. 主线程调用epoll_wait等socket上有数据可读。
3. 当socket上有数据可读时，epoll_wait通知主线程，主线程将socket可读事件放入请求队列
4. 睡眠在请求队列上的某个工作线程被唤醒，他从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
5. 当主线程调用epoll_wait等待socket可写。
6. 当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列。
7.睡眠在请求度脸上的某个工作线程被唤醒，他往socket上写入服务器处理客户请求的结果
## proactor模式
proactor模式将所有的IO操作都交给主线程和内核来处理(进行读.写)，工作线程仅仅负责业务逻辑。使用异步io模型(以aio_read和aio_write为例)实现的Proactor模式的工作流程是：
1. 主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序(以信号为例)

2. 主线程继续处理其他逻辑
3. 当socket上的数据被读入用户缓冲区后，内核将向应用程序发一个信号，以通知应用程序数据已经可用。
4.应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求，工作线程处理完客户请求后，调用aio_write函数将内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序
5. 主线程继续处理其他逻辑
6. 当用户缓冲区的数据被写如socket之后，内核将向应用程序发一个信号，以通知应用程序数据已经完全发送完毕。
7.应用程序预先定义好的型号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。