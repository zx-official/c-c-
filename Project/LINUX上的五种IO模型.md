# LINUX上的五种IO模型
## 阻塞(blocking)
- 调用者调用了某个函数，等待这个函数返回，期间什么都不做，不停的去检查这个函数有没有返回，必须等待这个函数返回才能进行下一步动作。

## 非阻塞(non-blocking)
- 没隔一段时间就去检测IO事件是否就绪，没有就绪就可以做其他事。非阻塞IO执行系统调用总是立即返回，不管时间是否已经发生，若事件没有发生则返回-1，此时可以根据errno区分这两中情况，对于accept，recv和send，事件未发生时，errno通常被设置成EAGAIN(数据还没准备好)。

## io复用(一次检测多个客户端的事件  在单进程单线程时)
- linux使用select pool epool 函数实现io复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作，而且可以同时对多个读操作，写操作的io函数进行检测，直到有数据可读或可写时，才真正调用IO操作函数

## 信号驱动
- linux用套接口进行信号驱动IO，安装一个信号驱动函数，进程继续运行并不阻塞，当io事件就绪，进程收到SIGIO信号，然后处理IO事件

- 内核在注册信号处理函数阶段是异步执行的，但数据准备好要从内核态将数据返回给用户态时的io（read）的操作时同步的

## 异步
- linux中可以调用aio_read()函数告诉内核描述字缓冲区指针和缓冲区的大小，文件偏移和通知的方式，然后立即返回，当内核将数据拷贝到缓冲区(用户缓冲区)后，再通知应用程序
